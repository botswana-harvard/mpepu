% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{bhp\_crypto Documentation}
\date{August 01, 2012}
\release{1.0}
\author{erik van widenfelt}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Overview}
\label{overview:overview}\label{overview::doc}\label{overview:bhp-crypto}
Module \code{bhp\_crypto} provides django model field classes that encrypt.
\begin{enumerate}
\item {} 
Depending on the length of the text field required, either RSA or AES encryption is used.

\item {} 
Not all field classes use the same encryption keys, so field value types can be
grouped by the key pair used and user access to un-encrypted values can be managed
according to these groupings.

\item {} 
Unique field constraints are maintained through the combined use of hashing and
ciphering values.

\item {} 
Only the hashed and ciphered value are stored.

\item {} 
Search is possible but only for exact value matches.

\end{enumerate}

\begin{notice}{note}{Note:}
Field level encryption protects data at rest but by itself is not
sufficient to protect a system. Any project that uses \code{bhp\_crypto}
should be deployed on a system that uses full-drive encryption and the
best of BIOS and OS level security features.
\end{notice}


\chapter{Before You Begin}
\label{before_you_begin::doc}\label{before_you_begin:before-you-begin}
Once \code{bhp\_crypto} is installed, review the models in your applications to identify fields that should use encryption.
A data model is well designed if all the personally identifying information (PII) is kept in a just a few models. In the
EDC, PII is found in model \emph{registered\_subject}, the locator models and the consent models.

\begin{notice}{warning}{Warning:}
Thoroughly test before implementing \code{bhp\_crypto} in production or with real data.
\end{notice}

\begin{notice}{warning}{Warning:}
Have a secure backup of encryption keys. Without the keys, data is lost.
\end{notice}


\chapter{Installation}
\label{installation:installation}\label{installation::doc}
\begin{notice}{warning}{Warning:}
Try \code{bhp\_crypto} in a test environment first.
\end{notice}

Copy your existing project and dataset into your test environment.

Checkout the latest version of \code{bhp\_crypto} into your test environment project folder:

\begin{Verbatim}[commandchars=\\\{\}]
svn co http://192.168.1.50/svn/bhp\_crypto
\end{Verbatim}

Checkout two additional modules:

\begin{Verbatim}[commandchars=\\\{\}]
svn co http://192.168.1.50/svn/bhp\_base\_model
svn co http://192.168.1.50/svn/bhp\_common
\end{Verbatim}

Add \code{bhp\_crypto} to your project `'settings'' file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{INSTALLED\PYGZus{}APPS} \PYG{o}{=} \PYG{p}{(}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.auth}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.contenttypes}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.sessions}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.sites}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.messages}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.staticfiles}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.admin}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django.contrib.admindocs}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{django\PYGZus{}extensions}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{audit\PYGZus{}trail}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{bhp\PYGZus{}base\PYGZus{}model}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{bhp\PYGZus{}common}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{bhp\PYGZus{}crypto}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{)}
\end{Verbatim}

Add these attributes to the bottom of your project `'settings'' file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} bhp\PYGZus{}crypto settings}
\PYG{n}{KEY\PYGZus{}PATH}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{/Volume/protected\PYGZus{}keys/keys}\PYG{l+s}{'} \PYG{c}{\PYGZsh{} truecrypt volume recommended!}
\PYG{n}{IS\PYGZus{}SECURE\PYGZus{}DEVICE}\PYG{o}{=}\PYG{n+nb+bp}{False}
\end{Verbatim}

Protect the keys! Point \textbf{KEY\_PATH} to a folder on a {\hyperref[protecting_keys_with_truecrypt::doc]{\emph{truecrypt}}} drive.

Generate new encryption keys:

\begin{Verbatim}[commandchars=\\\{\}]
python manage.py shell\_plus

\textgreater{}\textgreater{}\textgreater{}from bhp\_crypto.utils import setup\_new\_keys()
\textgreater{}\textgreater{}\textgreater{}setup\_new\_keys()
\textgreater{}\textgreater{}\textgreater{}exit()
\end{Verbatim}

Check that your keys were created and BACK THEM UP immediately:

\begin{Verbatim}[commandchars=\\\{\}]
ls keys/

erikvw@mac:\textasciitilde{}/source/bhp056\_project/bhp056\$  ls keys
user-aes-local
user-encrypted-salt
user-public-irreversible.pem
user-public-restricted.pem
user-private-restricted.pem
user-public-local.pem
user-private-local.pem
\end{Verbatim}

Your keys should be protected when in rest. See {\hyperref[protecting_keys_with_truecrypt::doc]{\emph{Protecting Keys with Truecrypt}}}.


\chapter{Protecting Keys with Truecrypt}
\label{protecting_keys_with_truecrypt:protecting-keys-with-truecrypt}\label{protecting_keys_with_truecrypt::doc}
The EDC is designed to run on a secure server or an independent mobile device such as a netbook.
In the latter case, securing the \emph{encryption keys} is an important concern and storing the keys
in a \textbf{truecrypt} encrypted mountable file is one approach.

\begin{notice}{tip}{Tip:}
See BHP's SOP on managing netbooks deployed in a disconnected environment
\end{notice}

Download, install and create a \textbf{truecrypt} encrypted file:

\begin{Verbatim}[commandchars=\\\{\}]
http://www.truecrypt.org/downloads
\end{Verbatim}

Point \code{bhp\_crypto} to the \textbf{truecrypt} encrypted file by editing the KEY\_PATH attribute in the project \emph{settings} file. For example,
if the \textbf{truecrypt} volume \emph{project\_keys} is mounted and the keys are in a sub-folder
named \emph{keys}:

On macosx:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{KEY\PYGZus{}PATH}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{/Volume/project\PYGZus{}keys/keys}\PYG{l+s}{'}
\end{Verbatim}

On ubuntu:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{KEY\PYGZus{}PATH}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{/media/project\PYGZus{}keys/keys}\PYG{l+s}{'}
\end{Verbatim}


\chapter{Pre-loading Keys}
\label{preloading_keys::doc}\label{preloading_keys:pre-loading-keys}
The encryption key \emph{files} are not required once the EDC has loaded. All keys are
pre-loaded at start up. This would be once \emph{runserver} or \emph{apache} are up.

Since the keys are pre-loaded into memory at start-up, the encryption key \emph{files} are not
actually required after start-up and you may remove them as a security measure.

If the encryption key \emph{files} are first read from a mounted truecrypt drive on the device,
it would be simple enough to unmount the drive once apache has started.

Even better, use sshfs to remotely mount the truecrypt drive, start apache, and unmount
the drive (or disconnect from the network).

This last option is ideal since you get all the functionality of \code{bhp\_crypto} without
storing the encryption key \emph{files} on the device.


\chapter{Generating Keys}
\label{generating_keys:generating-keys}\label{generating_keys::doc}
\begin{notice}{warning}{Warning:}
Keys should be safely stored and properly backed up.
\end{notice}

The EDC is often deployed on disconnected mobile devices. In this environment the keys are stored on the device
and should be secured inside a mountable \emph{truecrypt} file (see also {\hyperref[protecting_keys_with_truecrypt::doc]{\emph{Protecting Keys with Truecrypt}}}).

Use the \emph{settings} attribute \emph{KEY\_PATH} to indicate the location of the mounted truecrypt file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{KEY\PYGZus{}PATH}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{/Volume/project\PYGZus{}keys/keys}\PYG{l+s}{'}
\end{Verbatim}

With the KEY\_PATH attribute set, generate new keys:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{manage}\PYG{o}{.}\PYG{n}{py} \PYG{n}{generate\PYGZus{}keys}
\end{Verbatim}

The new keys will be in the KEY\_PATH folder:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{user}\PYG{o}{-}\PYG{n}{aes}\PYG{o}{-}\PYG{n}{local}
\PYG{n}{user}\PYG{o}{-}\PYG{n}{encrypted}\PYG{o}{-}\PYG{n}{salt}
\PYG{n}{user}\PYG{o}{-}\PYG{n}{public}\PYG{o}{-}\PYG{n}{irreversible}\PYG{o}{.}\PYG{n}{pem}
\PYG{n}{user}\PYG{o}{-}\PYG{n}{public}\PYG{o}{-}\PYG{n}{restricted}\PYG{o}{.}\PYG{n}{pem}
\PYG{n}{user}\PYG{o}{-}\PYG{n}{private}\PYG{o}{-}\PYG{n}{restricted}\PYG{o}{.}\PYG{n}{pem}
\PYG{n}{user}\PYG{o}{-}\PYG{n}{public}\PYG{o}{-}\PYG{n}{local}\PYG{o}{.}\PYG{n}{pem}
\PYG{n}{user}\PYG{o}{-}\PYG{n}{private}\PYG{o}{-}\PYG{n}{local}\PYG{o}{.}\PYG{n}{pem}
\end{Verbatim}

\begin{notice}{note}{Note:}
Keys load from the files into memory when apache is started on a netbook after which the key files may be removed. To avoid storing keys on the device, set the KEY\_PATH to a remote drive and disconnect from the remote drive once apache is started.
\end{notice}


\chapter{Choosing a Field Class for Your Model}
\label{selecting_field_classes:choosing-a-field-class-for-your-model}\label{selecting_field_classes::doc}
Field classes in \code{bhp\_crypto} are designed to protect sensitive data stored in models. In a clinical trail setting, any
model field that contains \textbf{personally identifying information} (PII) must use encryption. Some examples of PII include a
subject's first and last name, identity number, cell number, address, directions to a residence, names of relatives and date of birth.

`'bhp\_crypto'' offers field classes that use either RSA and AES encryption. RSA is used for short text and AES for long text.

If \code{bhp\_crypto} does not have the required keys to encrypt a field value, an error will be raised on any attempt to save data.

All data additions and changes will raise an error if the restricted and local RSA private keys are unavailable to the application.


\section{RSA Encryption}
\label{selecting_field_classes:rsa-encryption}
There are three types of RSA field classes where the difference is determined by the existence or availability of the private RSA key:
\begin{enumerate}
\item {} \begin{description}
\item[{\textbf{Irreversible RSA}: the saved value is never to be decrypted. Uses only a public RSA key:}] \leavevmode\begin{itemize}
\item {} 
public key \emph{user-public-irreversible.pem}

\item {} 
private key \emph{does not exist!}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\textbf{Restricted RSA}: private key and normally NOT stored on the device running the application. Uses RSA keys:}] \leavevmode\begin{itemize}
\item {} 
public key \emph{user-public-restricted.pem}

\item {} 
private key \emph{user-private-restricted.pem} .

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\textbf{Local RSA}: private key is usually available to the device running the application. Uses RSA keys:}] \leavevmode\begin{itemize}
\item {} 
public key \emph{user-public-local.pem}

\item {} 
private key \emph{user-private-local.pem}

\end{itemize}

\end{description}

\end{enumerate}


\subsection{Usage}
\label{selecting_field_classes:usage}
Irreversible RSA can be used to collect information meant to remain anonymous. For example, collecting samples at
multiple time points form a subject whose identity must remain anonymous but needs to be confirmed and linked in data.
By using Irreversible RSA, the field class creates a hash and secret of the PII but no private key exists
to reverse the encryption.

Restricted RSA is useful for the subject's identity number and lastname. Under normal operation, the private key is
not available to the application and these values are cannot be decrypted during normal use.

Local RSA is used for PII that unfortunately is needed for normal operation of the EDC. This includes values such as
\emph{first name, initials, date of birth, cell number, relative's name, and any other moderately sensitive value*}.


\section{AES Encryption}
\label{selecting_field_classes:aes-encryption}
AES encryption uses a secret AES key stored in \emph{user-aes-local}. The key is stored as an RSA secret created with the LocalRSA cipher.
This means that the local-rsa private key must be available for AES encryption. Uses keys:
\begin{itemize}
\item {} 
aes key \emph{user-aes-local}

\item {} 
private key \emph{user-private-local.pem} (required to decrypt the aes key)

\end{itemize}

Note that AES and Local RSA are linked by the same private key. The reason for this is that the level of security required
for data saved using either method is expected to be the same.

By removing the \emph{local-rsa} private key, an attempt to save a field value through a field class using AES will raise an error.


\subsection{Usage}
\label{selecting_field_classes:id1}
Use AES encryption for an field that is a long text and may contain sensitive information. A locator form with
\emph{directions to a household} or a \emph{comment} field on a consent document are good examples.


\section{Application, Data and Keys}
\label{selecting_field_classes:application-data-and-keys}\begin{itemize}
\item {} 
A dataset with encrypted PII is only de-identified by removing BOTH the restricted and local RSA private keys from the application.

\item {} 
the AES key is not available if the local RSA private key is not available

\item {} 
AES encryption is not possible if the AES key is not available

\item {} 
If a field class cannot encrypt a value, an error will be raised.

\end{itemize}


\chapter{Examples}
\label{examples::doc}\label{examples:examples}
Review your consent models, locator models and any other models that store personally identifying information.
Replace the current field class with a \code{bhp\_crypto}  field class.


\section{National Identity Number}
\label{examples:national-identity-number}
For example, on a consent form the national identity number is documented in the field \emph{identity}. \code{bhp\_crypto}
provides a field class for \emph{identity} which is a subclass of \code{RestrictedRsaEncryptionField} and, as the
class name suggests, employs RSA encryption using the \textbf{restricted-rsa} key pair. A \code{RestrictedRsaEncryptionField}
does not require the private key to be available to the EDC for normal operation. This is a good choice for the
\emph{identity number} as once the \emph{identity number} is captured there is usually no reason to decrypted it.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{django.db.models} \PYG{k+kn}{import} \PYG{n}{CharField}

\PYG{k}{class} \PYG{n+nc}{ConsentModel}\PYG{p}{(}\PYG{n}{BaseModel}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n}{identity} \PYG{o}{=} \PYG{n}{CharField}\PYG{p}{(}
        \PYG{n}{max\PYGZus{}length}\PYG{o}{=}\PYG{l+m+mi}{35}\PYG{p}{,}
        \PYG{n}{null}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
        \PYG{n}{blank}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
        \PYG{p}{)}
\end{Verbatim}

would become:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{bhp\PYGZus{}crypto.fields} \PYG{k+kn}{import} \PYG{n}{EncryptedIdentityField}

\PYG{k}{class} \PYG{n+nc}{ConsentModel}\PYG{p}{(}\PYG{n}{BaseModel}\PYG{p}{)}\PYG{p}{:}

    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n}{identity} \PYG{o}{=} \PYG{n}{EncryptedIdentityField}\PYG{p}{(}
        \PYG{n}{null}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
        \PYG{n}{blank}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}
        \PYG{p}{)}
\end{Verbatim}


\chapter{ModelAdmin}
\label{model_admin::doc}\label{model_admin:modeladmin}
\code{bhp\_crypto} provides a model admin class.


\chapter{ModelAdmin Actions}
\label{actions:module-actions}\label{actions:modeladmin-actions}\label{actions::doc}\index{actions (module)}

\chapter{Search on Encrypted Fields}
\label{searching:search-on-encrypted-fields}\label{searching::doc}

\chapter{Django Settings Attributes}
\label{settings:django-settings-attributes}\label{settings::doc}
\textbf{KEY\_PATH}: indicates the location of the keys folder. This is relative to the project folder.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{KEY\PYGZus{}PATH}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{keys}\PYG{l+s}{'}
\end{Verbatim}

\textbf{IS\_SECURE\_DEVICE}: If `'True'' suppresses a warning that the `'restricted-rsa'' private key should not be available on insecure devices.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{IS\PYGZus{}SECURE\PYGZus{}DEVICE}\PYG{o}{=}\PYG{n+nb+bp}{False}
\end{Verbatim}


\chapter{Management Tools}
\label{management::doc}\label{management:management-tools}\phantomsection\label{base_classes:module-bhp_crypto.classes}\index{bhp\_crypto.classes (module)}

\chapter{Classes}
\label{base_classes:classes}\label{base_classes::doc}
These classes do most of the work in \code{bhp\_crypto}, especially {\hyperref[base_classes:bhp_crypto.classes.Cryptor]{\code{Cryptor}}} and {\hyperref[base_classes:bhp_crypto.classes.FieldCryptor]{\code{FieldCryptor}}}.
\index{BaseCryptor (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.BaseCryptor}\pysigline{\strong{class }\code{bhp\_crypto.classes.}\bfcode{BaseCryptor}}
Bases: \code{bhp\_string.classes.base\_string.BaseString}
\index{is\_encrypted() (bhp\_crypto.classes.BaseCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.BaseCryptor.is_encrypted}\pysiglinewithargsret{\bfcode{is\_encrypted}}{\emph{value}, \emph{prefix=None}}{}
The value string is considered encrypted if it starts
with `self.HASH\_PREFIX' or whichever prefix is passed.

\end{fulllineitems}

\index{mask() (bhp\_crypto.classes.BaseCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.BaseCryptor.mask}\pysiglinewithargsret{\bfcode{mask}}{\emph{value}, \emph{mask='\textless{}encrypted\textgreater{}'}}{}
Help format values for display by masking them if encrypted
at the time of display.

\end{fulllineitems}


\end{fulllineitems}

\index{Cryptor (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.classes.}\bfcode{Cryptor}}{\emph{algorithm}, \emph{mode=None}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.classes.base\_cryptor.BaseCryptor}

Base class for all classes providing RSA and AES encryption methods.
\index{aes\_decrypt() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.aes_decrypt}\pysiglinewithargsret{\bfcode{aes\_decrypt}}{\emph{secret}, \emph{is\_encoded=True}, \emph{**kwargs}}{}
AES decrypts a value using the random iv stored with the secret where
secret is a tuple (secret\_text, sep, iv).

Will return plaintext or the original secret tuple

\end{fulllineitems}

\index{aes\_encrypt() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.aes_encrypt}\pysiglinewithargsret{\bfcode{aes\_encrypt}}{\emph{plaintext}, \emph{**kwargs}}{}
Returns secret as a tuple (secret,iv) or fail.

\end{fulllineitems}

\index{get\_encrypted\_salt() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.get_encrypted_salt}\pysiglinewithargsret{\bfcode{get\_encrypted\_salt}}{\emph{algorithm}, \emph{mode}}{}
Sets and returns the encrypted\_salt for the given algorithm and mode.

Gets from PRELOADED\_KEYS or reads from the file but will always reset it.

\end{fulllineitems}

\index{is\_preloaded\_with\_keys() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.is_preloaded_with_keys}\pysiglinewithargsret{\bfcode{is\_preloaded\_with\_keys}}{\emph{msg=None}}{}
Checks if keys are preloaded and returns False on the first missing key.

If msg is passed, will run through all keys displaying a message for each
missing key.

\end{fulllineitems}

\index{preload\_all\_keys() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.preload_all_keys}\pysiglinewithargsret{\bfcode{preload\_all\_keys}}{}{}
Forces all keys to be loaded into preload dictionary .

\end{fulllineitems}

\index{rsa\_decrypt() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.rsa_decrypt}\pysiglinewithargsret{\bfcode{rsa\_decrypt}}{\emph{secret}, \emph{is\_encoded=True}, \emph{**kwargs}}{}
Returns plaintext or secret if the private key is not available.

Secret is base64 encoded unless `is\_encoded' is false.

\end{fulllineitems}

\index{rsa\_encrypt() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.rsa_encrypt}\pysiglinewithargsret{\bfcode{rsa\_encrypt}}{\emph{plaintext}, \emph{**kwargs}}{}
Return an un-encoded secret or fail.

\end{fulllineitems}

\index{set\_aes\_key() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.set_aes_key}\pysiglinewithargsret{\bfcode{set\_aes\_key}}{\emph{**kwargs}}{}
Decrypted and set the AES key using the rsa private key for the given mode.
\begin{description}
\item[{Keyword Arguments:}] \leavevmode\begin{itemize}
\item {} 
algorithm -- must be `aes' (default: no default).

\item {} 
mode -- the mode dictionary key. For example local (default: no default).

\end{itemize}

\end{description}

\begin{notice}{note}{Note:}
have not implemented default values for keyword args as a precaution for an incorrectly configured instance.
\end{notice}

\end{fulllineitems}

\index{set\_private\_key() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.set_private_key}\pysiglinewithargsret{\bfcode{set\_private\_key}}{\emph{keyfile=None}, \emph{**kwargs}}{}
Load the rsa private key and return True, if available, otherwise return False.
\begin{description}
\item[{`irreversible' does not have a private key so:}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{keyfile} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{VALID\PYGZus{}MODES}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{algorithm}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{mode}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{private}\PYG{l+s}{'}\PYG{p}{,} \PYG{n+nb+bp}{None}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{keyfile}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb+bp}{None}
\end{Verbatim}

\item[{Keyword Arguments:}] \leavevmode\begin{itemize}
\item {} 
algorithm -- rsa, aes (default: no default).

\item {} 
mode -- the mode dictionary key. For example local (default: no default).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{set\_public\_key() (bhp\_crypto.classes.Cryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Cryptor.set_public_key}\pysiglinewithargsret{\bfcode{set\_public\_key}}{\emph{keyfile=None}, \emph{**kwargs}}{}
Load the rsa public key.
\begin{description}
\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
algorithm: rsa, aes (default: no default).

\item {} 
mode: the mode dictionary key. For example local (default: no default).

\end{itemize}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{FieldCryptor (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.FieldCryptor}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.classes.}\bfcode{FieldCryptor}}{\emph{algorithm}, \emph{mode}}{}
Bases: \code{object}

Subclass to be used with models that expect to stored just the hash and for this class to handle the secret.
\index{decrypt() (bhp\_crypto.classes.FieldCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.FieldCryptor.decrypt}\pysiglinewithargsret{\bfcode{decrypt}}{\emph{secret}, \emph{secret\_is\_hash=True}, \emph{**kwargs}}{}
Decrypt secret and if secret is a hash, use hash to lookup the real secret first.

Do not assume secret is an encrypted value, look for HASH\_PREFIX or secret prefix.
By default we expect secret to be the stored field value -- which is a hash.
If we use this method for a secret that is not a hash, then the prefix is
the SECRET\_PREFIX and the lookup step is skipped.

\end{fulllineitems}

\index{encrypt() (bhp\_crypto.classes.FieldCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.FieldCryptor.encrypt}\pysiglinewithargsret{\bfcode{encrypt}}{\emph{value}, \emph{**kwargs}}{}
Return the encrypted field value (hash+secret) where secret is secret or secret+secret\_iv.

\end{fulllineitems}

\index{get\_hash() (bhp\_crypto.classes.FieldCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.FieldCryptor.get_hash}\pysiglinewithargsret{\bfcode{get\_hash}}{\emph{value}}{}
Returns the hashed value without hash\_prefix by either splitting it from value or hashing value.

\end{fulllineitems}

\index{get\_prep\_value() (bhp\_crypto.classes.FieldCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.FieldCryptor.get_prep_value}\pysiglinewithargsret{\bfcode{get\_prep\_value}}{\emph{encrypted\_value}, \emph{value}, \emph{**kwargs}}{}
Gets the hash from encrypted value for the DB

\end{fulllineitems}

\index{update\_secret\_in\_lookup() (bhp\_crypto.classes.FieldCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.FieldCryptor.update_secret_in_lookup}\pysiglinewithargsret{\bfcode{update\_secret\_in\_lookup}}{\emph{hash\_secret}}{}
Given a hash+secret string, updates lookup with hashed\_value and secret pairs

\end{fulllineitems}


\end{fulllineitems}

\index{Hasher (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Hasher}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.classes.}\bfcode{Hasher}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{object}

handle all hashing
\index{get\_hash() (bhp\_crypto.classes.Hasher method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.Hasher.get_hash}\pysiglinewithargsret{\bfcode{get\_hash}}{\emph{value}, \emph{algorithm}, \emph{mode}, \emph{salt}}{}
Returns a salted value as an iterated SHA256 hash

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{base_classes:module-bhp_crypto.fields}\index{bhp\_crypto.fields (module)}

\chapter{Management Classes}
\label{base_classes:management-classes}
These classes are used mostly by the management commands.
\index{ModelCryptor (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor}\pysigline{\strong{class }\code{bhp\_crypto.classes.}\bfcode{ModelCryptor}}
Bases: \code{object}
\index{decrypt\_instance() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.decrypt_instance}\pysiglinewithargsret{\bfcode{decrypt\_instance}}{\emph{instance}, \emph{encrypted\_field\_object=\textless{}class `bhp\_crypto.classes.base\_encrypted\_field.BaseEncryptedField'\textgreater{}}}{}
Returns a modified instance (not saved), encrypt all un-encrypted
field objects in a given model instance.

\end{fulllineitems}

\index{decrypt\_model() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.decrypt_model}\pysiglinewithargsret{\bfcode{decrypt\_model}}{\emph{model}}{}
decrypt and save all encrypted field objects in a given model

\end{fulllineitems}

\index{encrypt\_instance() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.encrypt_instance}\pysiglinewithargsret{\bfcode{encrypt\_instance}}{\emph{instance}, \emph{save=True}}{}
Encrypts the instance by calling save\_base (not save!).

\end{fulllineitems}

\index{encrypt\_model() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.encrypt_model}\pysiglinewithargsret{\bfcode{encrypt\_model}}{\emph{model}, \emph{save=True}, \emph{**kwargs}}{}
Encrypts instances for a given model.

Selects a queryset of unencrypted instances to operate on.

Keyword Arguments:
print\_on\_save -- print a message to stdout on each save (default: True)
save\_message -- message to print after each instance is saved which may include \{0\}
and \{1\} for `instance\_count', `instance\_total' (default: 37/35666 instances encrypted ...).
field\_name -- filter unencrypted instances on the field object with this attname only.

\end{fulllineitems}

\index{get\_all\_encrypted\_models() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.get_all_encrypted_models}\pysiglinewithargsret{\bfcode{get\_all\_encrypted\_models}}{}{}
Returns a dictionary of models per app in the format \{app\_name: {[}encrypted\_models, ...{]}\}.

\end{fulllineitems}

\index{get\_encrypted\_fields() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.get_encrypted_fields}\pysiglinewithargsret{\bfcode{get\_encrypted\_fields}}{\emph{model}, \emph{**kwargs}}{}
Returns a list of field objects that use encryption.

Keyword Arguments:
field\_name -- return a list with field object of this attname only. Name is ignored if not a field using encrytion.

\end{fulllineitems}

\index{get\_encrypted\_models() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.get_encrypted_models}\pysiglinewithargsret{\bfcode{get\_encrypted\_models}}{\emph{app\_name}, \emph{**kwargs}}{}
Returns a dictionary of model objects that contain encrypted fields
in the format \{ model\_name: \{model, fields\}\}.

\end{fulllineitems}

\index{is\_instance\_encrypted() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.is_instance_encrypted}\pysiglinewithargsret{\bfcode{is\_instance\_encrypted}}{\emph{**kwargs}}{}
Check if field values in instance are encrypted.

Note: this is much slower than just saving the instance!!

Keyword Arguments:
instance -- a model instance (default: None)
field\_name -- filter on the field object with this attname only
suppress\_messages -- whether to print messages to stdout (default: False)

\end{fulllineitems}

\index{is\_model\_encrypted() (bhp\_crypto.classes.ModelCryptor method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.ModelCryptor.is_model_encrypted}\pysiglinewithargsret{\bfcode{is\_model\_encrypted}}{\emph{**kwargs}}{}
Check if instances in model are encrypted.
Note: this is much slower than just saving the instances!!

Keyword Arguments:
model -- checks all instances within model (default: None)
field\_name -- filter on the field object with this attname only
suppress\_messages -- whether to print messages to stdout (default: False)

\end{fulllineitems}


\end{fulllineitems}

\index{KeyGenerator (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.KeyGenerator}\pysigline{\strong{class }\code{bhp\_crypto.classes.}\bfcode{KeyGenerator}}
Bases: \code{object}
\index{get\_key\_paths() (bhp\_crypto.classes.KeyGenerator method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.KeyGenerator.get_key_paths}\pysiglinewithargsret{\bfcode{get\_key\_paths}}{}{}
Returns a list of key pathnames

\end{fulllineitems}

\index{test\_keys() (bhp\_crypto.classes.KeyGenerator method)}

\begin{fulllineitems}
\phantomsection\label{base_classes:bhp_crypto.classes.KeyGenerator.test_keys}\pysiglinewithargsret{\bfcode{test\_keys}}{}{}
Tests keys

\end{fulllineitems}


\end{fulllineitems}



\chapter{Field Classes}
\label{field_classes::doc}\label{field_classes:field-classes}

\section{Field Base Classes}
\label{field_classes:field-base-classes}\index{BaseEncryptedField (class in bhp\_crypto.classes)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.classes.}\bfcode{BaseEncryptedField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{django.db.models.fields.Field}

A base field class to store sensitive data at rest in an encrypted
format.
\begin{itemize}
\item {} 
To maintain uniqueness and searchability, only the hash is ever
stored in the model field.

\item {} 
The cipher is stored with the hash in the \code{bhp\_crypto.models.
Crypt} cipher lookup model and will be
made available when required for decryption (e.g. the private key is
available)

\item {} 
Salt, public key filename and private key filename are referred to
via the settings file

\end{itemize}
\index{decrypt() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.decrypt}\pysiglinewithargsret{\bfcode{decrypt}}{\emph{value}, \emph{**kwargs}}{}
wrap the cryptor method of same name

\end{fulllineitems}

\index{encrypt() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.encrypt}\pysiglinewithargsret{\bfcode{encrypt}}{\emph{value}, \emph{**kwargs}}{}
wrap the cryptor method of same name

\end{fulllineitems}

\index{get\_internal\_type() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.get_internal_type}\pysiglinewithargsret{\bfcode{get\_internal\_type}}{}{}
This is a Charfield as we only ever store the hash, which is a         fixed length char.

\end{fulllineitems}

\index{get\_prep\_lookup() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.get_prep_lookup}\pysiglinewithargsret{\bfcode{get\_prep\_lookup}}{\emph{lookup\_type}, \emph{value}}{}
Only decrypts the stored value to handle `exact' and `in'
but excepts `icontains' as if it is `exact' so that the admin
search fields work.

Also, `startswith' does not decrypt and may only be used to check for the hash\_prefix.
All others are errors.

\end{fulllineitems}

\index{get\_prep\_value() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.get_prep_value}\pysiglinewithargsret{\bfcode{get\_prep\_value}}{\emph{value}, \emph{encrypt=True}}{}
Returns the hashed\_value with prefix (or None) and, if needed, updates the secret lookup.

Keyword arguments:
encrypt -- if False, the value is returned as is (default True)

\end{fulllineitems}

\index{is\_encrypted() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.is_encrypted}\pysiglinewithargsret{\bfcode{is\_encrypted}}{\emph{value}}{}
wrap the cryptor method of same name

\end{fulllineitems}

\index{south\_field\_triple() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.south_field_triple}\pysiglinewithargsret{\bfcode{south\_field\_triple}}{}{}
Returns a suitable description of this field for South.

\end{fulllineitems}

\index{to\_python() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.to_python}\pysiglinewithargsret{\bfcode{to\_python}}{\emph{value}}{}
Returns the decrypted value IF the private key is found, otherwise returns
the encrypted value.

Value comes from DB as a hash (e.g. \textless{}hash\_prefix\textgreater{}\textless{}hashed\_value\textgreater{}). If DB value is being
acccessed for the first time, value is not an encrypted value (not a prefix+hashed\_value).

\end{fulllineitems}

\index{validate\_with\_cleaned\_data() (bhp\_crypto.classes.BaseEncryptedField method)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.classes.BaseEncryptedField.validate_with_cleaned_data}\pysiglinewithargsret{\bfcode{validate\_with\_cleaned\_data}}{\emph{attname}, \emph{cleaned\_data}}{}
May be overridden to test field data against other values
in cleaned data.

Should raise a forms.ValidationError if the test fails
\begin{enumerate}
\item {} 
`attname' is the key in cleaned\_data for the value to be tested,

\item {} 
`cleaned\_data' comes from django.forms clean() method

\end{enumerate}

\end{fulllineitems}


\end{fulllineitems}

\index{IrreversibleRsaEncryptionField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.fields.IrreversibleRsaEncryptionField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{IrreversibleRsaEncryptionField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.classes.base\_encrypted\_field.BaseEncryptedField}

Sames as Restricted except the private key does not exist so values can never be decrypted..

\end{fulllineitems}

\index{RestrictedRsaEncryptionField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.fields.RestrictedRsaEncryptionField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{RestrictedRsaEncryptionField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.classes.base\_encrypted\_field.BaseEncryptedField}

private key is NOT expected to be available and it's absence is enforced

\end{fulllineitems}

\index{LocalRsaEncryptionField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.fields.LocalRsaEncryptionField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{LocalRsaEncryptionField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.classes.base\_encrypted\_field.BaseEncryptedField}

\end{fulllineitems}

\index{LocalAesEncryptionField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_classes:bhp_crypto.fields.LocalAesEncryptionField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{LocalAesEncryptionField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.classes.base\_encrypted\_field.BaseEncryptedField}

For encrypting long text

\end{fulllineitems}



\chapter{Field SubClasses for Models}
\label{field_subclasses:field-subclasses-for-models}\label{field_subclasses::doc}

\section{RSA Encryption}
\label{field_subclasses:rsa-encryption}
RSA encryption supports short text fields. IN :mod: `bhp\_crypto' it is deployed at three levels of security:
\begin{enumerate}
\item {} 
Irreversible RSA: private key does not exist.

\item {} 
Restricted RSA: private key exists but is often not available to the device running the application.

\item {} 
Local RSA: private key is usually available to the device running the application

\end{enumerate}

In all cases, all private keys may be removed to disable the rsa\_decrypt() method.

\textbf{Resrticted RSA}
\index{EncryptedLastnameField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedLastnameField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedLastnameField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.restricted\_rsa\_encryption\_field.RestrictedRsaEncryptionField}

\end{fulllineitems}

\index{EncryptedIdentityField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedIdentityField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedIdentityField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.restricted\_rsa\_encryption\_field.RestrictedRsaEncryptionField}

\end{fulllineitems}


\textbf{Local RSA}
\index{EncryptedFirstnameField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedFirstnameField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedFirstnameField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_rsa\_encryption\_field.LocalRsaEncryptionField}

Restricted-rsa encrypted field for a model's Firstname attribute.

\end{fulllineitems}

\index{EncryptedCharField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedCharField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedCharField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_rsa\_encryption\_field.LocalRsaEncryptionField}

\end{fulllineitems}

\index{EncryptedIntegerField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedIntegerField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedIntegerField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_rsa\_encryption\_field.LocalRsaEncryptionField}
\index{to\_python() (bhp\_crypto.fields.EncryptedIntegerField method)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedIntegerField.to_python}\pysiglinewithargsret{\bfcode{to\_python}}{\emph{value}}{}
Returns as integer

\end{fulllineitems}


\end{fulllineitems}

\index{EncryptedDecimalField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedDecimalField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedDecimalField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_rsa\_encryption\_field.LocalRsaEncryptionField}
\index{to\_python() (bhp\_crypto.fields.EncryptedDecimalField method)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedDecimalField.to_python}\pysiglinewithargsret{\bfcode{to\_python}}{\emph{value}}{}
Returns as integer

\end{fulllineitems}


\end{fulllineitems}



\section{AES Encryption}
\label{field_subclasses:aes-encryption}
AES Encryption supports long text field. The keys, though protected, are on the device running the application.
\index{EncryptedAesCharField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedAesCharField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedAesCharField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_aes\_encryption\_field.LocalAesEncryptionField}

\end{fulllineitems}

\index{EncryptedTextField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedTextField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedTextField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_aes\_encryption\_field.LocalAesEncryptionField}

\end{fulllineitems}

\index{EncryptedOtherCharField (class in bhp\_crypto.fields)}

\begin{fulllineitems}
\phantomsection\label{field_subclasses:bhp_crypto.fields.EncryptedOtherCharField}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.fields.}\bfcode{EncryptedOtherCharField}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_crypto.fields.local\_aes\_encryption\_field.LocalAesEncryptionField}

\end{fulllineitems}

\phantomsection\label{field_subclasses:module-bhp_crypto.utils}\index{bhp\_crypto.utils (module)}

\chapter{Models}
\label{models:models}\label{models::doc}
\code{bhp\_crypto} uses a \textbf{secrets} lookup model searchable by hash.
\index{Crypt (class in bhp\_crypto.models)}

\begin{fulllineitems}
\phantomsection\label{models:bhp_crypto.models.Crypt}\pysiglinewithargsret{\strong{class }\code{bhp\_crypto.models.}\bfcode{Crypt}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{bhp\_sync.classes.base\_sync\_model.BaseSyncModel}

A secrets lookup model searchable by hash
\begin{quote}\begin{description}
\item[{Name }] \leavevmode
Crypt

\item[{Table }] \leavevmode
bhp\_crypto\_crypt

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{hash} (\emph{CharField}) -- Hash

\item {} 
\textbf{secret} (\emph{TextField}) -- Secret

\item {} 
\textbf{algorithm} (\emph{CharField}) -- Algorithm

\item {} 
\textbf{mode} (\emph{CharField}) -- Mode

\item {} 
\textbf{salt} (\emph{CharField}) -- Salt

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Utilities}
\label{utilities::doc}\label{utilities:module-bhp_crypto.utils}\label{utilities:utilities}\index{bhp\_crypto.utils (module)}\index{setup\_new\_keys (class in bhp\_crypto.utils)}

\begin{fulllineitems}
\phantomsection\label{utilities:bhp_crypto.utils.setup_new_keys}\pysigline{\strong{class }\code{bhp\_crypto.utils.}\bfcode{setup\_new\_keys}}
Utility to generate all new keys for the project.

\end{fulllineitems}


see {\hyperref[generating_keys::doc]{\emph{Generating Keys}}}


\chapter{FAQ}
\label{faq:faq}\label{faq::doc}

\section{Where is the RSA or AES secret stored?}
\label{faq:where-is-the-rsa-or-aes-secret-stored}
Only the hash of the value is stored in the model field while the \emph{secret} is stored in a lookup table along with the hash. When
the value is needed, the field class retrieves the \emph{secret} by searching the lookup table on the hash.


\section{Is it still possible to search on encrypted fields?}
\label{faq:is-it-still-possible-to-search-on-encrypted-fields}
Yes, but only exact matches are possible as the search is on the hash of the value and not the value itself.

To search on RSA fields, the public keys are needed.

To search on AES fields the `'local-rsa'' private key and the AES key are required.

Note that hashing is used because the cipher object does not create the same \emph{secret} each time it ciphers a given value.


\chapter{ToDo}
\label{todo:todo}\label{todo::doc}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{actions}}, \pageref{actions:module-actions}
\indexspace
\bigletter{b}
\item {\texttt{bhp\_crypto.classes}}, \pageref{base_classes:module-bhp_crypto.classes}
\item {\texttt{bhp\_crypto.fields}}, \pageref{base_classes:module-bhp_crypto.fields}
\item {\texttt{bhp\_crypto.utils}}, \pageref{utilities:module-bhp_crypto.utils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
